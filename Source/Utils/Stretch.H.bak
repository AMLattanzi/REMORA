#ifndef STRETCH_H_
#define STRETCH_H_

#include "DataStruct.H"
#include "ROMSX.H"

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
set_depth (int lev)
{
    auto& lev_new = vars_new[lev];
    auto& lev_old = vars_old[lev];
    std::unique_ptr<MultiFab>& mf_z_w = z_w[lev];
    std::unique_ptr<MultiFab>& mf_z_r = z_r[lev];
    std::unique_ptr<MultiFab>& mf_Hz  = Hz[lev];
    std::unique_ptr<MultiFab>& mf_h  = hOfTheConfusingName[lev];
    mf_h->setval(geom[lev].ProbHi(2));
    std::unique_ptr<MultiFab>& mf_Zt_avg1  = Zt_avg1[lev];
    mf_Zt_avg1->setVal(0.0);

    for ( MFIter mfi(lev_new[Vars::cons], TilingIfNotGPU()); mfi.isValid(); ++mfi )
    {
      /*
      FArrayBox& z_w_fab = (*mf_z_w)[mfi];
      FArrayBox& z_r_fab = (*mf_z_r)[mfi];
      FArrayBox& Hz_fab  = (*mf_Hz)[mfi];
      */

      Array4<Real> const& z_w_arr = (mf_z_w)->array(mfi);
      Array4<Real> const& z_r_arr = (mf_z_r)->array(mfi);
      Array4<Real> const& Hz_arr  = (mf_Hz)->array(mfi);
      const Box& bx = mfi.tilebox();
      Array4<Real> const& h_arr  = (mf_h)->array(mfi);

      int ncomp = 1;
      Box subdomain;
      if (lev == 0) {
          subdomain = geom[lev].Domain();
      } else {
          subdomain = boxes_at_level[lev][which_subdomain];
      }

      int nx = subdomain.length(0);
      int ny = subdomain.length(1);
      int nz = subdomain.length(2);

      auto N = nz; // Number of vertical "levels" aka, NZ
      Real hc=min(geomdata.ProbLo(0),tcline); // Do we need to enforce min here?
      // ROMS Transform 2
      amrex::ParallelFor(bx, ncomp,
      [=] AMREX_GPU_DEVICE (int i, int j, int k, int n)
      {
	//        const Real z = prob_lo[2] + (k + 0.5) * dx[2];
        const auto prob_lo         = geomdata.ProbLo();
        const auto dx              = geomdata.CellSize();
	//This is the z for the bottom of the cell this k corresponds to
	//   if we weren't stretching and transforming
        const Real z = prob_lo[2] + (k) * dx[2];
	//	h_arr(i,j) = -z; // conceptually
	

	h_arr(i,j) = -prob_lo[2];
        /*
        Real cff_r=hc*sc_r(k);
        Real cff_w=hc*sc_w(k);
        Real cff1_r=Cs_r(k);
        Real cff1_w=Cs_w(k);
        */

        ////////////////////////////////////////////////////////////////////
        //ROMS Stretching 4
        // Move this block to it's own function for maintainability if needed
        // Information about the problem dimension would need to be added
        // This file would need a k dependent function to return the 
        // stretching scalars, or access to 4 vectors of length prob_length(2)
        /////////////////////////////////////////////////////////////////////
        /*
        const auto prob_lo         = geomdata.ProbLo();
        const auto dx              = geomdata.CellSize();
        const Real z = prob_lo[2] + (k) * dx[2];
        */
	Real ds = 1.0_rt / z;
	
	Real cff_r, cff_w, cff1_r, cff1_w, Csur, Cbot;
	if(k==N-1) // end of array
	{
	cff_w=0.0; //sc_w / hc
        cff1_w=0.0; //Cs_w
	}
	else if (k==0) // beginning of array
	{
  	cff_w=-1.0; //sc_w / hc
        cff1_w=-1.0; //Cs_w
	}
	else
	{
	  cff_w=ds*(k-N);
          if (theta_s > 0.0_rt)
            Csur=(1.0_dp-std::cosh(theta_s*sc_w))/
	      (std::cosh(theta_s)-1.0_rt);
          else
            Csur=-sc_w*sc_w;
          if (theta_b > 0.0_rt)
	  {
            Cbot=(std::exp(theta_b*Csur)-1.0_rt)/
	      (1.0_rt-std::exp(-theta_b));
	    cff1_w=Cbot;
	  }
	  else
            cff1_w=Csur;
	}
	cff_w*=hc;
	//cff_r => sc_r *hc
	//cff1_r => Cs_r
	//Don't do anything special for first/last index
	{
	  cff_r=ds*(k-N-0.5_rt);
          if (theta_s > 0.0_rt)
            Csur=(1.0_dp-std::cosh(theta_s*sc_r))/
	      (std::cosh(theta_s)-1.0_rt);
          else
            Csur=-sc_r*sc_r;
          if (theta_b > 0.0_rt)
	  {
            Cbot=(std::exp(theta_b*Csur)-1.0_rt)/
	      (1.0_rt-std::exp(-theta_b));
	    cff1_r=Cbot;
	  }
	  else
            cff1_r=Csur;
	}
        ////////////////////////////////////////////////////////////////////
	Real hwater=h_arr(i,j);
	if(k==0)
          z_w(i,j,k) = -h_arr(i,j);
        }
        else
	{
	//Note, we are not supporting ICESHELF flag
	  hinv=1.0_r8/(hc+hwater);
	  cff2_r=(cff_r+cff1_r*hwater)*hinv;
	  cff2_w=(cff_w+cff1_w*hwater)*hinv;

	  z_w(i,j,k)=Zt_avg1(i,j)+(Zt_avg1(i,j)+hwater)*cff2_w;
	  z_r(i,j,k)=Zt_avg1(i,j)+(Zt_avg1(i,j)+hwater)*cff2_r;
	//Note, we are not supporting ICESHELF flag
	  Hz(i,j,k)=z_w(i,j,k)-z_w(i,j,k-1);
	}
      });

    } // mf
  
}

AMREX_GPU_DEVICE
AMREX_FORCE_INLINE
void
set_depth_z_r ()
{


}
#endif
